#include <LiquidCrystal.h>

// Configurare LCD: pinii (RS, E, D4, D5, D6, D7)
LiquidCrystal lcd(7, 6, 5, 4, 3, 2);

// Definire pini pentru senzori și butoane
const int buzzerPin = 8;
const int fotosenzorPin = A3;
const int potentiometruPin = A0;
const int buton1Pin = A1;
const int buton2Pin = A2;

// Definire Pini Registru Deplasare
const int latchPin = 10;
const int clockPin = 9;
const int dataPin = 11;

// Pattern-uri pentru afișajul cu 7 segmente
byte digits[] = {
  0b11111010, // 0
  0b01100000, // 1
  0b11011100, // 2
  0b11110100, // 3
  0b01100110, // 4
  0b10110110, // 5
  0b10111110, // 6
  0b11100000, // 7
  0b11111110, // 8
  0b11100110  // 9
};

// Stări Joc
enum GameState {
  IDLE,
  WAITING_FOR_ACTION,
  ACTION_IN_PROGRESS,
  ROUND_LOST
};
GameState currentGameState = IDLE;

// Variabile Joc
int score = 0;
int currentActionID = 0;
unsigned long actionStartTime = 0;
int timeLimitSeconds = 5;
const int minTimeLimitSeconds = 2;
const int maxTimeLimitSeconds = 5;

// Acțiuni Posibile
enum PlayerAction {
  PRESS_BUTTON_1,
  PRESS_BUTTON_2,
  COVER_PHOTORESISTOR,
  TURN_POTENTIOMETER,
  NUM_ACTIONS
};
String actionDescriptions[] = {
  "Apasa Buton 1!",
  "Apasa Buton 2!",
  "Acopera Senzor!",
  "Roteste Pot.!"
};

// Praguri pentru senzori
const int FOTOSENSOR_THRESHOLD_COVERED = 300;
const int POTENTIOMETER_THRESHOLD_HIGH = 700;

// Timp debounce butoane
const unsigned long DEBOUNCE_DELAY = 50;

// Funcții pentru Afișajul cu 7 Segmente
void clearDisplaySevenSegment() {
  setDisplay(0b00000000);
}

byte getDigit(int i, bool period = false) {
  if (i >= 0 && i < 10) {
    if (period == false) {
      return digits[i];
    } else {
      return digits[i] | 0b00000001;
    }
  }
  return 0b00000000;
}

void setDisplay(byte code) {
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, LSBFIRST, code);
  digitalWrite(latchPin, HIGH);
}

// Funcție nouă: verifică acțiuni nepermise
bool isWrongActionPerformed() {
  switch (currentActionID) {
    case PRESS_BUTTON_1:
      if (isButtonPressed(buton2Pin)) return true;
      if (analogRead(fotosenzorPin) < FOTOSENSOR_THRESHOLD_COVERED) return true;
      if (analogRead(potentiometruPin) > POTENTIOMETER_THRESHOLD_HIGH) return true;
      break;
    case PRESS_BUTTON_2:
      if (isButtonPressed(buton1Pin)) return true;
      if (analogRead(fotosenzorPin) < FOTOSENSOR_THRESHOLD_COVERED) return true;
      if (analogRead(potentiometruPin) > POTENTIOMETER_THRESHOLD_HIGH) return true;
      break;
    case COVER_PHOTORESISTOR:
      if (isButtonPressed(buton1Pin)) return true;
      if (isButtonPressed(buton2Pin)) return true;
      if (analogRead(potentiometruPin) > POTENTIOMETER_THRESHOLD_HIGH) return true;
      break;
    case TURN_POTENTIOMETER:
      if (isButtonPressed(buton1Pin)) return true;
      if (isButtonPressed(buton2Pin)) return true;
      if (analogRead(fotosenzorPin) < FOTOSENSOR_THRESHOLD_COVERED) return true;
      break;
  }
  return false;
}

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);
  lcd.print("Joc Actiune!");
  lcd.setCursor(0, 1);
  lcd.print("Apasa B1 Start");

  pinMode(buzzerPin, OUTPUT);
  pinMode(fotosenzorPin, INPUT);
  pinMode(potentiometruPin, INPUT);
  pinMode(buton1Pin, INPUT_PULLUP);
  pinMode(buton2Pin, INPUT_PULLUP);
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);

  clearDisplaySevenSegment();
  randomSeed(analogRead(A4));
}

void loop() {
  switch (currentGameState) {
    case IDLE:
      handleIdleState();
      break;
    case WAITING_FOR_ACTION:
      handleWaitingForActionState();
      break;
    case ACTION_IN_PROGRESS:
      handleActionInProgressState();
      break;
    case ROUND_LOST:
      handleRoundLostState();
      break;
  }
}

void handleIdleState() {
  if (isButtonPressed(buton1Pin)) {
    score = 0;
    timeLimitSeconds = maxTimeLimitSeconds;
    lcd.clear();
    lcd.print("Pregatire...");
    clearDisplaySevenSegment();
    delay(1000);
    currentGameState = WAITING_FOR_ACTION;
  }
}

void handleWaitingForActionState() {
  currentActionID = random(0, NUM_ACTIONS);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(actionDescriptions[currentActionID]);
  lcd.setCursor(0, 1);
  lcd.print("Scor: ");
  lcd.print(score);
  setDisplay(getDigit(timeLimitSeconds));
  actionStartTime = millis();
  currentGameState = ACTION_IN_PROGRESS;
}

void handleActionInProgressState() {
  unsigned long currentTime = millis();
  unsigned long elapsedTime = currentTime - actionStartTime;
  int remainingTimeSeconds = timeLimitSeconds - (elapsedTime / 1000);

  if (remainingTimeSeconds >= 0) {
    setDisplay(getDigit(remainingTimeSeconds));
  } else {
    setDisplay(getDigit(0));
  }

  if (elapsedTime >= (unsigned long)timeLimitSeconds * 1000) {
    currentGameState = ROUND_LOST;
    return;
  }

  // Verificare acțiune greșită
  if (isWrongActionPerformed()) {
    currentGameState = ROUND_LOST;
    return;
  }

  // Verificare acțiune corectă
  bool actionCompleted = false;
  switch (currentActionID) {
    case PRESS_BUTTON_1:
      if (isButtonPressed(buton1Pin)) actionCompleted = true;
      break;
    case PRESS_BUTTON_2:
      if (isButtonPressed(buton2Pin)) actionCompleted = true;
      break;
    case COVER_PHOTORESISTOR:
      if (analogRead(fotosenzorPin) < FOTOSENSOR_THRESHOLD_COVERED) actionCompleted = true;
      break;
    case TURN_POTENTIOMETER:
      if (analogRead(potentiometruPin) > POTENTIOMETER_THRESHOLD_HIGH) actionCompleted = true;
      break;
  }

  if (actionCompleted) {
    score++;
    lcd.setCursor(8, 1);
    lcd.print(" OK!");
    if (score > 0 && score % 3 == 0) {
      if (timeLimitSeconds > minTimeLimitSeconds) {
        timeLimitSeconds--;
      }
    }
    if (timeLimitSeconds < minTimeLimitSeconds) timeLimitSeconds = minTimeLimitSeconds;
    delay(600);
    currentGameState = WAITING_FOR_ACTION;
  }
}

void handleRoundLostState() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Runda Pierduta!");
  lcd.setCursor(0, 1);
  lcd.print("Scor Final: ");
  lcd.print(score);
  clearDisplaySevenSegment();
  tone(buzzerPin, 250, 500);
  delay(500);
  tone(buzzerPin, 200, 500);
  delay(1500);
  currentGameState = IDLE;
  lcd.clear();
  lcd.print("Joc Actiune!");
  lcd.setCursor(0, 1);
  lcd.print("Apasa B1 Start");
}

bool isButtonPressed(int buttonPin) {
  static unsigned long lastDebounceTime[2] = {0, 0};
  static bool lastButtonState[2] = {HIGH, HIGH};
  static bool currentButtonStableState[2] = {HIGH, HIGH};
  static bool buttonPressedEvent[2] = {false, false};

  int buttonIndex = (buttonPin == buton1Pin) ? 0 : 1;
  bool eventDetected = false;
  bool reading = digitalRead(buttonPin);

  if (reading != lastButtonState[buttonIndex]) {
    lastDebounceTime[buttonIndex] = millis();
  }

  if ((millis() - lastDebounceTime[buttonIndex]) > DEBOUNCE_DELAY) {
    if (reading != currentButtonStableState[buttonIndex]) {
      currentButtonStableState[buttonIndex] = reading;
      if (currentButtonStableState[buttonIndex] == LOW) {
        buttonPressedEvent[buttonIndex] = true;
      }
    }
  }
  lastButtonState[buttonIndex] = reading;

  if (buttonPressedEvent[buttonIndex]) {
    buttonPressedEvent[buttonIndex] = false;
    eventDetected = true;
  }
  return eventDetected;
}
